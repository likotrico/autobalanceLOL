# -*- coding: utf-8 -*-
"""autobalanceLOL.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eQlhPLPbUWmuMjG9l11K0CwqfWTHW5G4
"""

from itertools import product
import numpy as np
import pandas as pd

url = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQgYDcaAxMbk8LgVi64GJm8dluCYk1MZ5uoeyhr6cgYh5OIqrr0tW01w-b449-uYDsL9xuFqGgvesar/pub?gid=0&single=true&output=csv'
dataset = pd.read_csv(url)

def normalizeLP(dataset):
  max = np.inf * -1
  min = np.inf
  for i in dataset['points']:
    if i > max:
      max = i
    if i < min:
      min = i
  for i in range(len(dataset['points'])):
    dataset.at[i, 'normalized'] = (dataset.iloc[i, 1] - min)/(max - min)

normalizeLP(dataset)

if dataset["top"].dtype != float and dataset["top"].dtype != int:
  dataset["top"] = dataset["top"].apply(lambda x: float(x.replace(",",".")))

if dataset["jg"].dtype != float and dataset["jg"].dtype != int:
  dataset["jg"] = dataset["jg"].apply(lambda x: float(x.replace(",",".")))

if dataset["mid"].dtype != float and dataset["mid"].dtype != int:
  dataset["mid"] = dataset["mid"].apply(lambda x: float(x.replace(",",".")))

if dataset["adc"].dtype != float and dataset["adc"].dtype != int:
  dataset["adc"] = dataset["adc"].apply(lambda x: float(x.replace(",",".")))

if dataset["sup"].dtype != float and dataset["sup"].dtype != int:
  dataset["sup"] = dataset["sup"].apply(lambda x: float(x.replace(",",".")))

#DEFININDO A CLASSE JOGADOR
class Player:
    def __init__(self, name, points, int, *lane_points):
        self.name = name
        self.points = points
        self.int = int
        self.lane_points = lane_points

    def getInt(self):
        return self.int

    def getPoints(self):
        return self.points

    def getName(self):
        return self.name

    def getLanePoints(self, index):
      return self.lane_points[index]

players = []
for i in range(len(dataset["nick"])):
  players.append(Player(dataset.iloc[i, 0], dataset.iloc[i, 8], dataset.iloc[i, 2], dataset.iloc[i, 3], dataset.iloc[i, 4], dataset.iloc[i, 5], dataset.iloc[i, 6] ,dataset.iloc[i, 7]))

def func(blueteam, redteam):
  pointsBlue = 0
  pointsRed = 0
  for i, p in enumerate(blueteam):
    pointsBlue += p.getLanePoints(i)+p.getPoints()

  for i, p in enumerate(redteam):
    pointsRed += p.getLanePoints(i)+p.getPoints()

  return [abs(pointsBlue - pointsRed), pointsBlue, pointsRed]

#FUNÇÃO QUE VERIFICA SE EXISTE UM ELEMENTO REPETIDO NO ELEMENTO DO ARRANJO
def haveTwice(lista):
    count1 = 0
    count2 = 0
    count3 = 0
    count4 = 0
    count5 = 0
    count6 = 0
    count7 = 0
    count8 = 0
    count9 = 0
    count10 = 0
    for element in lista:
        #print(element)
        #print(f"teste: {element == 10}")
        if element == 1:
            count1 = count1 + 1
        if element == 2:
            count2 = count2 + 1
        if element == 3:
            count3 = count3 + 1
        if element == 4:
            count4 = count4 + 1
        if element == 5:
            count5 = count5 + 1
        if element == 6:
            count6 = count6 + 1
        if element == 7:
            count7 = count7 + 1
        if element == 8:
            count8 = count8 + 1
        if element == 9:
            count9 = count9 + 1
        if element == 10:
            #print("entrou")
            count10 = count10 + 1
    #print(f"count10: {count10}")
    if count1 >= 2 or count2 >= 2 or count3 >= 2 or count4 >= 2 or count5 >= 2 or count6 >= 2 or count7 >= 2 or count8 >= 2 or count9 >= 2 or count10 >= 2:
        return True
    return False

#CRIANDO UMA LISTA DE INTEIROS DE 1 ATÉ 10 QUE REPRESENTARÁ OS INTEIROS ASSOCIADOS AOS PLAYERS
caracteres = [1,2,3,4,5,6,7,8,9,10]
permsList = []
#USANDO A FUNÇÃO DO ITERTOOLS PARA OBTER TODOS SO ARRANJOS COM REPETIÇÃO DE 5 ESPAÇOS DE 10 ELEMENTOS DISTINTOS
genComb = product(caracteres, repeat=5) # aqui e onde tens de especificar o numero de chars que cada combinacao tenha
#COLOCANDO O RESULTADO DO ARRANJO EM UMA LISTA
for subset in genComb:
    #print(subset) # tuple retornado com uma combinacao por loop
    permsList.append(subset)

#VERIFICANDO OS ELEMENTOS DO ARRANJO QUE TEM UM PELO MENOS UM DOS ELEMENTOS REPETIDOS E COLETANDO SEUS INDICES NA LISTA
#CASO NÃO EXISTA NO MÍNIMO DOIS ELEMENTOS REPETIDOS, OU SEJA, TODOS OS ELEMENTOS SÃO DIFERENTES NO ARRANJO, PEGAMOS SEU INDICE
indexList = []
num = 0
for j in range(len(permsList)):
    if haveTwice(permsList[j]):
        num+=1
    else:
        indexList.append(j)

#AO COLOCAR APENAS OS ELEMENTOS DO ARRANJO QUE NÃO TEM ELEMENTO REPETIDO, OBTEMOS A COMBINAÇÃO DE 5 ESPAÇOS DE 10 ELEMENTOS DISTINTOS.
#A OPERAÇÃO É REALIZADA COLOCANDO OS INDICES COLETADOS QUE SATISFAZEM A CONDIÇÃO EM UMA NOVA LISTA
newList = []
for i in indexList:
    newList.append(permsList[i])
permsList.clear()

#VARIÁVEL DA DIFERENÇA SETADA COMO INFINITO. COMO QUEREMOS DOIS TIMES COM A MENOR DIFERENÇA DE PONTOS,
#O VALOR INICIAL É COLOCADO COMO INFINITO PARA PEGARMOS A PRIMEIRA DIFERENÇA
mindiff = np.inf
team = []
allteams = []
contador = 0

for comb in newList:
    #AQUI VAMO TER UMA LISTA QUE ARMAZENARÁ A LISTA PLAYER, NO CASO A BLUETEAM. DEPOIS, VERIFICANDO OS ELEMENTOS DA COMBINAÇÃO,
    #VAMOS
    blueTeam = players.copy()
    redTeam = []
    AuxIndexList = []
    #COLETANDO OS INDICES DA LISTA CUJO INTEIRO DO PLAYER CONDIZ COM OS NUMERO PRESENTE NA COMBINAÇÃO
    for integer in comb:
        for element in range(len(players)):
            if players[element].getInt() == integer:
                AuxIndexList.append(element)
    #ADICIONANDO OS PLAYERS QUE TEM OS INTEIROS CONDIZENTES COM O ELEMENTO DA COMBINAÇÃO ATUAL
    for i in AuxIndexList:
        redTeam.append(blueTeam[i])

    #REMOVENDO OS ELEMENTOS QUE ESTÃO NO REDTEAM DA LISTA DO BLUETEAM, QUE INICIALMENTE POSSUI TODOS OS PLAYERS
    for i in redTeam:
        for j in blueTeam:
            if i.getInt() == j.getInt():
                blueTeam.remove(j)

    #REALIZANDO A DIFERENÇA DA SOMA DOS PONTOS DOS TIMES RESULTANTES DA COMBINAÇÃO VERIFICADA
    test = func(blueTeam, redTeam)
    medianAux = test[0]
    bluesum = test[1]
    redsum = test[2]

    """if contador < 5:
      allteams.append([redTeam.copy(), blueTeam.copy(), medianAux])
      contador += 1"""
    if medianAux <= 0.001:
      allteams.append([redTeam.copy(), blueTeam.copy(), medianAux])

    #SE A COMBINAÇÃO ATUAL RESULTOU EM UMA DIFERENÇA MENOR, ENTÃO É A COMBINAÇÃO QUE DESEJAMOS
    #SENDO ASSIM, ARMAZENAMOS A NOVA DIFERENÇA E OS TIMES DA COMBINAÇÃO.
    if medianAux < mindiff:
        mindiff = medianAux
        team = redTeam.copy()
        team2 = blueTeam.copy()
        bs = bluesum
        rs = redsum

    redTeam.clear()
    AuxIndexList.clear()

#MOSTRAR OS TIMES RESULTANTES
if len(team) == len(team2):
    a = 0
    b = 0
    for i in range(len(team)):
        a+= team[i].points
        b+= team2[i].getPoints()
        print(f"Index:{team[i].getInt()} / Player:{team[i].getName()}\t Index:{team2[i].getInt()} / Player:{team2[i].getName()}")
    print(f"Pontos totais:\nTime 1:{rs}\nTime 2:{bs}")
    print(f"Diferença:{mindiff}")

else:
    print("Times com tamanhos diferentes! Um Erro aconteceu")

len(allteams)

def sortTeams(allTeams):
  result = []
  for i in allTeams:
    if len(result) == 0:
      result.append(i)
    else:
      var = False
      for j in range(len(result)):
        if i[2] <= result[j][2]:
          result.insert(j, i)
          var = True
          break
      if var == False:
        result.append(i)
  return result

def showSortedTeams(sortedTeams):
  for i in sortedTeams:
    print('-----------------------------------------------------------------------')
    for j in range(5):
      print(f"Index:{i[0][j].getInt()} / Player:{i[0][j].getName()}\t Index:{i[1][j].getInt()} / Player:{i[1][j].getName()}")
    print(f"Diferença:{i[2]}")
    print('-----------------------------------------------------------------------')

abc = sortTeams(allteams)

len(abc)

showSortedTeams(abc)